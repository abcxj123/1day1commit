## Generic
### Generic이란
- Generic이란 데이터 형식에 의존하지 않고, 하나의 값이 여러 다른 데이터 타입들을 가질 수 있도록 하는 방법이다.
- Generic은 클래스 내부에서 지정하는 것이 아닌 **외부에서 사용자에 의해 지정**되는 것을 의미한다.

### Generic의 장점

- 제네릭을 사용하면 **잘못된 타입**이 들어올 수 있는 것을 **컴파일 단계**에서 **방지**할 수 있다.
- 클래스 **외부에서 타입을 지정**해주기 때문에 따로 **타입을 체크하고 변환해줄 필요가 없다**. 즉, 관리하기가 편하다.
- 비슷한 기능을 지원하는 경우 **코드의 재사용성이 높아진다**.

### Generic의 단점
- 제네릭을 처음 마주하는 경우 이해하기가 어렵다.
- 단순하게 제네릭만 사용하는 경우가 아닌, 상속과 구현 등 계층구조가 복잡해지면 코드를 이해하기 어려워진다.

## Vue와 React
### 공통점
- 가상 DOM을 활용하여 효율적으로 리랜더링이 가능하다. (SPA)
- 반응적이고 조합 가능한 컴포넌트를 제공한다.
- 라우팅 및 전역 상태를 관리하는 라이브러리가 있다.

### 차이점
- React는 단방향 데이터 바인딩이고, Vue는 양방향 데이터 바인딩을 이용한다.
- React는 JSX 형태로 코드를 작성하여 JS만을 사용하여 UI와 DOM을 구현한다.
- Vue의 가상 DOM 구현이 React보다 빠르며, 오버헤드가 적게 발생한다.
- React에서 모든 컴포넌트는 JSX를 사용하여 JSX의 툴을 이용해 Vue의 템플릿보다 진보된 기능을 사용할 수 있다.
- Vue는 템플릿을 사용하여 쉽고 빠르게 제작이 가능하며, 진입장벽이 낮다.

### 정리
- React는 확장성이 좋으나 자바스크립트 문법에 능숙해야하며, 커스터마이징 및 자유도가 높은편이다. 또한, 커뮤니티 형성이 잘 되어있고 큰 프로젝트에 용이하다.
- Vue는 제공되는 HTML 기반의 템플릿이 있어 진입장벽이 낮고 프로젝트를 빠르게 만들 수 있다. 개발자간 코드가 통일성 있으며, 소규모 프로젝트에 용이하다.

## 라이브러리와 프레임워크
### 라이브러리
- 라이브러리란 개발자가 만든 클래스들의 나열로, 다른 프로그램들에서 사용할 수 있도록 제공하는 방식이다.

### 프레임워크
- 개발자가 소프트웨어를 개발함에 있어 코드를 구현하는 개발 시간을 줄이고, 코드의 재사용성을 증가시키기 위해 일련의 클래스 묶음이나 뼈대, 틀을 라이브러리 형태로 제공되는 것을 말한다.
- 제어의 역전 개념이 적용된 대표적인 기술이다.
- 개발자가 따라야 하는 가이드를 제공한다.
- 개발할 수 있는 범위가 정해져 있다.
- 개발자를 위한 다양한 도구

### 라이브러리와 프레임워크의 차이
- **제어 흐름에 대한 주도성이 누구에게 / 어디에 있는지가 다르다.**
- **프레임워크는 스스로 제어 흐름의 주도성을 갖는 반면, 라이브러리는 개발자가 가지고 있다.**
- 라이브러리와 달리 프레임워크는 이미 프로그래밍에 대한 규칙을 가지고 있다. 예를 들면, 설정 파일의 태그 설정이나, DB 연동 방법 등에 대한 규칙을 가지고 있고, 개발자는 이를 따라야 한다.
- 프레임워크는 집이고, 라이브러리는 그 집 안의 가구라고 볼 수 있다.

## Debounce와 Throttle
### Debounce와 Throttle
- 두 가지 방법 모두 DOM 이벤트를 기반으로 실행하는 자바스크립트를 성능상의 이유로 JS의 양적인 측면, 즉 이벤트를 제어하는 방법이다.
- 이벤트 핸들러가 많은 연산을 하는 경우에 대해 제약을 걸어, 제어할 수 있는 수준으로 이벤트를 발생시키는 것을 목표로 하는 기술이다.

### Debounce
- Debounce는 이벤트를 그룹화하여 특정시간이 지난 후 하나의 이벤트만 발생하도록 하는 기술이다. 즉, 연이어 호출되는 함수들 중 마지막 함수만 호출하도록 하는 것이다.
- 엘리베이터에서 닫기 버튼을 누르다 사람을 발견하여 열기 버튼을 누르면 최종적으로 누른 열기 버튼으로 인해 엘리베이터가 열리게 되는 것과 비슷하다.

### Throttle
- Throttle은 이벤트를 일정한 주기마다 발생하도록 하는 기술이다. 예를 들어, Throttle의 설정 시간으로 1ms를 주게 되면 해당 이벤트는 1ms 동안 최대 한 번만 발생하게 된다. 즉, 마지막 함수가 호출된 후 일정 시간이 지나기 전에 다시 호출되지 않도록 하는 것이다.
- 특성 자체가 실행 횟수에 제한을 거는 것이기 때문에 일반적으로 성능 문제를 해결하기 위해 많이 사용한다.
- 스크롤을 올리거나 내릴 때, scroll 이벤트 핸들러가 매우 많이 발생하게 된다. 발생할 때마다 복잡한 로직을 설정해두었다면, 큰 버퍼링이 걸릴 수 있다. 이럴 때 쓰로틀링을 사용하기에 적절하다.

## useState와 useRef
### 공통점
- 둘 다 함수형 컴포넌트에서 동적으로 상태 관리를 할 수 있게 해준다.

### 차이점
- useRef를 사용한 구현에서는 변경된 값을 화면에 띄우지 않는다. 왜냐하면, useState와 다르게 useRef는 state를 변화시킨 후에 component를 re-render하지 않기 때문이다.
- 따라서 useRef를 사용한 구현에서 state를 변화시키더라도 변화 후에 re-render가 되지 않아 initial value로 나타날 것이기 때문에 rendering을 할 수는 있지만, 변화했다는 의미가 존재하지 않아 따로 화면에 띄우지 않는다.
- 반면, useState의 경우 선언한 state의 setter function에 의해 update 될 경우, re-rendering process가 진행된다.
- 결과적으로, 각각의 state에서 이용할 hook을 설계할 때, 주로 **state의 rendering 여부를 바탕으로 결정**하는 것이 좋다.
- **Rendering이 필요한 state의 경우 useState**를 이용하는 것이 간편하게 상태관리를 할 수 있으며, **rendering이 필요하지 않은 state의 경우 useRef**를 쓰는 것이 간단하게 코드를 작성할 수 있다.
