## 인터럽트
- 인터럽트란 CPU가 프로그램을 실행하고 있을 때, 입출력 핟드웨어 등의 장치나 예외 상황이 발생하여 처리가 필요한 경우 마이크로프로세서에 알려져 이를 처리할 수 있도록 하는 것을 의미한다.
- 인터럽트 처리 루틴
주 프로그램 실행 -> 인터럽트 발생 -> 복귀주소 저장 -> 인터럽트 벡터로 점프 -> 인터럽트 처리 -> 인터럽트 처리 완료 -> 복귀 주소 로드 -> 마지막에 실행되던 주소로 점프 -> 주 프로그램 다시 실행

## Java String의 null과 ""의 차이
- null : 어떠한 값으로 초기화 되지 않는다. 따라서 힙 메모리 상에서 데이터를 만들지 않는다. 변수를 어떠한 값으로도 초기화 하지 않는다.
- 공백(””) : String 형으로 빈 값을 메모리에 할당한다. 변수를 빈 값으로 초기화하고 null과 달리 인스턴스화 된 객체를 참조한다.
- 공백의 경우 인스턴화 된 객체이므로 length, substring과 같은 문자열 관련 함수를 사용할 수 있지만, null의 경우에는 NullPointException 에러가 발생한다.

## Array, ArrayList, LinkedList
- Array와 ArrayList의 공통점
  - 값 접근의 성능이 O(1)이다.
  - 중복 요소 저장이 가능하다.
  - Null 저장 가능하다.
- Array와 ArrayList의 차이점
  - Array는 길이가 고정적이다. 한 번 Array를 생성하면 이후에 크기를 변경할 수 없다.
  - ArrayList는 길이가 가변적이다. ArrayList는 size를 나타내는 capacity 인스턴스 변수를 가지고 있는데, capacity보다 더 많은 객체가 들어오게 되면 ArrayList의 크기를 1.5배 증가시킨다. capacity의 기본 값은 10이다.
  - Array는 Primitive type과 Reference type 모두 저장 가능하지만, ArrayList는 Reference type만 저장 가능하다.
- ArrayList가 아닌 Array를 사용하는 상황은?
  - ArrayList는 중간에 데이터를 추가, 삭제 시 메모리를 재할당하기(데이터 삭제 시 그 자리를 하나씩 앞으로 땡겨서 채워준다. 메모리가 연속적이기 때문) 때문에 Array에 비해 속도가 느리다. 해당 작업을 많이 할 때에는 Array를 사용하는 것이 유리하다.
- ArrayList와 LinkedList의 차이점
  - ArrayList는 메모리 상에 데이터가 연속적으로 저장되고, LinkedList는 메모리 상에 데이터가 비연속적으로 저장된다.
  - 따라서 데이터 값을 가져올 때 ArrayList는 O(1), LinkedList는 O(N)의 성능을 가진다.
  - ArrayList에서 맨 앞, 맨 뒤에 데이터를 추가하거나, 삭제하는 것은 매우 빠르지만, 중간에 있는 데이터를 추가하거나 삭제할 때는 매우 느리다.
  - LinkedList는 중간에 값을 추가하거나 삭제해도 연결 상태만 변경해주면 되기 때문에 속도가 빠르다.

## 세션 기반 인증
- 서버 측에서 사용자들의 정보를 기억하고 있어야 한다.
- 클라이언트로부터 요청을 받으면, 클라이언트의 상태를 계속해서 유지하고 이 정보를 서비스에 이용하므로 Stateful한 구조를 갖는다.
- 정보가 서버에 저장되기 때문에 토큰 기반 인증에 비해 위변조 혹은 손상 우려가 없다.
- 서버에 세션을 저장하기 때문에 사용자가 증가하면 서버에 과부하를 줄 수 있어 확장성이 낮다.
- 쿠키는 단일 도메인 및 서브 도메인에서만 작동하도록 설계되어 있기 때문에 여러 도메인에서 관리하는 것이 번거롭다.

## 토큰 기반 인증
- 인증받은 사용자들에게 토큰을 발급하고, 서버에 요청을 할 때 헤더에 토큰을 함께 보내도록 유효성 검사를 하는 인증 방식이다.
- 서버 기반의 인증 시스템과 달리 상태를 유지하지 않으므로 Stateless한 구조를 갖는다.
- 쿠키를 더 이상 사용하지 않으므로 세션 하이재킹과 같은 취약점이 사라지게 된다.
- 토큰이 클라이언트 측에 저장되기 때문에 서버는 완전히 stateless하여 확장에 유리하다.
- 토큰 기반 인증 시스템에서는 토큰에 선택적인 권한만 부여하여 발급할 수 있으므로 서비스 확장에 유리하다.
- 서비스의 규모가 커지더라도 어떤 디바이스, 어떤 도메인에서도 토큰의 유효성 검사를 진행한 후에 요청을 처리할 수 있으므로 서버 기반 인증 시스템의 문제점 중 하나인 CORS를 해결할 수 있다.
