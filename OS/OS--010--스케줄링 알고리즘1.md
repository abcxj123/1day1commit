# Scheduling Algorithm
- 단일 처리 시스템에서는 실행 중인 프로세스가 존재하는데 다른 프로세스가 입출력을 요청하면 그 프로세스는 이전의 프로세스의 자원을 놓을 때까지 대기하고 있어야 한다.
- 하지만 다중 프로그래밍에서는 여러 프로세스들이 동시에 돌아갈 수 있으며, 프로세스가 자원을 요청하면 운영체제는 그 자원을 적절히 분배하여 프로세스에게 할당한다.
- 프로세스는 필요한 자원을 할당받기 위해 큐에 대기한다. 그 큐에 있는 프로세스를 어떻게 스케줄링 하는지를 프로세스 스케줄링 알고리즘이라고 한다.
***
### 1. FCFS(First-Come First-Served : nonpreemptive)
- 선입선처리(FCFS) 알고리즘은 말 그대로 먼저 요청한 프로세스가 먼저 자원을 제공받으며 이미 사용중이라면 사용이 끝날 때까지 기다려야 하는 스케줄링 방식이다.
- 장점 : 스케줄링이 단순하다, 모든 프로세스가 실행될 수 있다, 프로세서가 지속적으로 유용한 프로세스를 수행하여 처리율이 높다.
- 단점 : 비선점방식의 스케줄링이므로 대화형 작업에는 부적합하다, 앞의 프로세스가 오래 걸리면 프로세스 전체가 오래 걸린다.(**convoy effect**)
***
### 2. SJF(Shortest Job First)
- 최소 작업 우선(SJF) 스케줄링은 프로세스의 실행 시간을 이용하여 가장 짧은 시간을 갖는 프로세스가 먼저 자원을 할당받는 방식이다.
- 각 프로세스의 다음번 CPU burst time을 가지고 스케줄링에 활용한다.
- CPU burst time이 가장 짧은 프로세스를 제일 먼저 스케줄링한다.
- Nonpreemptive : 일단 CPU를 잡으면 이번 CPU burst가 완료될 때까지 CPU를 선점 당하지 않는다.
- Preemptive : 현재 수행중인 프로세스의 남은 burst time보다 더 짧은 CPU burst time을 가지는 새로운 프로세스가 도착하면 CPU를 빼앗긴다. 이 방법을 Shorst-Remaining-Time-First(SRTF)이라고도 부른다.
- 장점 : 항상 짧은 작업을 먼저 처리하게 돼서 평균 대기시간이 가장 짧다.
- 단점 : 수행 시간이 긴 작업은 짧은 작업에 밀려 기아가 발생한다, 실행 시간(CPU burst time)을 예측할 수 없어 실용적이지 못하다, 짧은 작업이 먼저 실행되므로 공정하지 못하다.
***
### 3. Priority Scheduling
- 우선순위 스케줄링은 프로세스마다 우선순위라는 속성이 붙게 된다.
- 우선순위 스케줄링도 선점, 비선점형으로 스케줄링이 가능하다.
- 숫자가 높을수록 우선순위가 높고 만약 우선순위가 같다면 FIFO 방식으로 동작한다.
- Higest priority를 가진 프로세스에게 CPU를 할당한다.
- SJF는 일종의 Priority Scheduling이다.
- 문제점 : 우선순위가 낮은 프로세스는 영원히 실행되지 않을 수도 있다. (**Starvation**)
- 해결방법 : 시간이 지나면 우선순위를 증가시킨다. (**Aging**)
